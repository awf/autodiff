/*        Generated by TAPENADE     (INRIA, Ecuador team)
	Tapenade 3.14 (master-db54337a6) - 29 Jul 2019 10:54
*/
/*
  Differentiation of sigmoid in forward (tangent) mode:
   variations   of useful results: sigmoid
   with respect to varying inputs: x
*/

#include "lstm_d.h"

// UTILS
// Sigmoid on scalar
double sigmoid_d(double x, double xd, double* sigmoid) {
	*sigmoid = 1.0 / (1.0 + exp(-x));
	return -(-(xd * exp(-x)) / ((1.0 + exp(-x)) * (1.0 + exp(-x))));
}

/*
  Differentiation of logsumexp in forward (tangent) mode:
   variations   of useful results: logsumexp
   with respect to varying inputs: *vect
   Plus diff mem management of: vect:in
*/
// log(sum(exp(x), 2))
double logsumexp_d(const double* const vect, const double* const vectd, int sz
	, double* logsumexp) {
	double sum = 0.0;
	double sumd;
	int i;
	sumd = 0.0;
	for (i = 0; i < sz; ++i) {
		sumd = sumd + vectd[i] * exp(vect[i]);
		sum += exp(vect[i]);
	}
	sum += 2;
	*logsumexp = log(sum);
	return sumd / sum;
}

/*
  Differentiation of lstm_model in forward (tangent) mode:
   variations   of useful results: alloc(*gates) *cell *hidden
   with respect to varying inputs: alloc(*gates) *cell *bias *hidden
				*weight *input
   Plus diff mem management of: cell:in bias:in hidden:in weight:in
				input:in
*/
// LSTM OBJECTIVE
// The LSTM model
void lstm_model_d(int hsize, const double* const weight, const double* const
	weightd, const double* const bias, const double* const biasd, double*
	hidden, double* hiddend, double* cell, double* celld, const double*
	const input, const double* const inputd) {
	double* gates;
	double* gatesd;
	int ii1;
	gatesd = (double*)malloc(4 * hsize * sizeof(double));
	for (ii1 = 0; ii1 < 4 * hsize; ++ii1)
		gatesd[ii1] = 0.0;
	gates = (double*)malloc(4 * hsize * sizeof(double));
	double* forget = &(gates[0]);
	double* forgetd = &(gatesd[0]);
	double* ingate = &(gates[hsize]);
	double* ingated = &(gatesd[hsize]);
	double* outgate = &(gates[2 * hsize]);
	double* outgated = &(gatesd[2 * hsize]);
	double* change = &(gates[3 * hsize]);
	double* changed = &(gatesd[3 * hsize]);
	int i;
	for (i = 0; i < hsize; ++i) {
		forgetd[i] = sigmoid_d(input[i] * weight[i] + bias[i], inputd[i] * weight[
			i] + input[i] * weightd[i] + biasd[i], &(forget[i
			]));
		ingated[i] = sigmoid_d(hidden[i] * weight[hsize + i] + bias[hsize + i],
			hiddend[i] * weight[hsize + i] + hidden[i] * weightd[
				hsize + i] + biasd[hsize + i], &(ingate[i]));
		outgated[i] = sigmoid_d(input[i] * weight[2 * hsize + i] + bias[2 * hsize + i]
			, inputd[i] * weight[2 * hsize + i] + input[i] *
			weightd[2 * hsize + i] + biasd[2 * hsize + i], &(
				outgate[i]));
		changed[i] = (hiddend[i] * weight[3 * hsize + i] + hidden[i] * weightd[3 * hsize + i
		] + biasd[3 * hsize + i]) * (1.0 - tanh(hidden[i] * weight[3 * hsize + i] + bias[3 *
			hsize + i]) * tanh(hidden[i] * weight[3 * hsize + i] + bias[3 * hsize + i]));
		change[i] = tanh(hidden[i] * weight[3 * hsize + i] + bias[3 * hsize + i]);
	}
	for (i = 0; i < hsize; ++i) {
		celld[i] = celld[i] * forget[i] + cell[i] * forgetd[i] + ingated[i] * change
			[i] + ingate[i] * changed[i];
		cell[i] = cell[i] * forget[i] + ingate[i] * change[i];
	}
	for (i = 0; i < hsize; ++i) {
		hiddend[i] = outgated[i] * tanh(cell[i]) + outgate[i] * celld[i] * (1.0 - tanh
		(cell[i]) * tanh(cell[i]));
		hidden[i] = outgate[i] * tanh(cell[i]);
	}
	free(gatesd);
	free(gates);
}

/*
  Differentiation of lstm_predict in forward (tangent) mode:
   variations   of useful results: alloc(*gates) *s *x2
   with respect to varying inputs: alloc(*gates) *s *w *w2 *x2
   Plus diff mem management of: s:in w:in w2:in x2:in
*/
// Predict LSTM output given an input
void lstm_predict_d(int l, int b, const double* const w, const double* const
	wd, const double* const w2, const double* const w2d, double* s, double
	* sd, const double* const x, double* x2, double* x2d) {
	int i;
	for (i = 0; i < b; ++i) {
		x2d[i] = x[i] * w2d[i];
		x2[i] = x[i] * w2[i];
	}
	double* xp = x2;
	double* xpd = x2d;
	for (i = 0; i <= 2 * l * b - 1; i += 2 * b) {
		lstm_model_d(b, &(w[i * 4]), &(wd[i * 4]), &(w[(i + b) * 4]), &(wd[(i + b) * 4]),
			&(s[i]), &(sd[i]), &(s[i + b]), &(sd[i + b]), xp, xpd);
		xpd = &(sd[i]);
		xp = &(s[i]);
	}
	for (i = 0; i < b; ++i) {
		x2d[i] = xpd[i] * w2[b + i] + xp[i] * w2d[b + i] + w2d[2 * b + i];
		x2[i] = xp[i] * w2[b + i] + w2[2 * b + i];
	}
}

/*
  Differentiation of lstm_objective in forward (tangent) mode:
   variations   of useful results: *loss
   with respect to varying inputs: *main_params *extra_params
   RW status of diff variables: *main_params:in *extra_params:in
				*loss:out
   Plus diff mem management of: extra_params:in loss:in
*/
// LSTM objective (loss function)
void lstm_objective_d(int l, int c, int b, const double* const main_params,
	const double* const main_paramsd, const double* const extra_params,
	const double* const extra_paramsd, double* state, const double* const
	sequence, double* loss, double* lossd) {
	double total = 0.0;
	double totald;
	int count = 0;
	const double* input = &(sequence[0]);
	double* ypred;
	double* ypredd;
	double* stated = (double*)malloc(2 * l * b * sizeof(double));
	ypredd = (double*)malloc(b * sizeof(double));
	ypred = (double*)malloc(b * sizeof(double));
	double* ynorm;
	double* ynormd;
	ynormd = (double*)malloc(b * sizeof(double));
	ynorm = (double*)malloc(b * sizeof(double));
	const double* ygold;
	double lse;
	double lsed;
	int i;
	int t;
	for (i = 0; i < 2 * l * b; i++)
		stated[i] = 0.0;
	totald = 0.0;
	for (t = 0; t <= (c - 1) * b - 1; t += b) {
		lstm_predict_d(l, b, main_params, main_paramsd, extra_params,
			extra_paramsd, state, stated, input, ypred, ypredd);
		lsed = logsumexp_d(ypred, ypredd, b, &lse);
		for (i = 0; i < b; ++i) {
			ynormd[i] = ypredd[i] - lsed;
			ynorm[i] = ypred[i] - lse;
		}
		ygold = &(sequence[t + b]);
		for (i = 0; i < b; ++i) {
			totald = totald + ygold[i] * ynormd[i];
			total += ygold[i] * ynorm[i];
		}
		count += b;
		input = ygold;
	}
	*lossd = -totald / count;
	*loss = -total / count;
	free(ypredd);
	free(ypred);
	free(ynormd);
	free(ynorm);
	free(stated);
}