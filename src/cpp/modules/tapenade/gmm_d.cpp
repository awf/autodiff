/*        Generated by TAPENADE     (INRIA, Ecuador team)
	Tapenade 3.14 (master-db54337a6) - 29 Jul 2019 10:54
*/

#include "gmm_d.h"

/*
  Differentiation of arr_max in forward (tangent) mode:
   variations   of useful results: arr_max
   with respect to varying inputs: *x
   Plus diff mem management of: x:in

 ====================================================================
								UTILS
 ==================================================================== */
 // This throws error on n<1
double arr_max_d(int n, const double* const x, const double* const xd, double
	* arr_max) {
	double m = x[0];
	double md = xd[0];
	{
		double tmpresult;
		for (int i = 1; i < n; ++i) {
			if (m < x[i]) {
				md = xd[i];
				m = x[i];
			}
		}
	}
	*arr_max = m;
	return md;
}

/*
  Differentiation of sqnorm in forward (tangent) mode:
   variations   of useful results: sqnorm
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
// sum of component squares
double sqnorm_d(int n, const double* const x, const double* const xd, double*
	sqnorm) {
	double res = x[0] * x[0];
	double resd = xd[0] * x[0] + x[0] * xd[0];
	for (int i = 1; i < n; ++i) {
		resd = resd + xd[i] * x[i] + x[i] * xd[i];
		res = res + x[i] * x[i];
	}
	*sqnorm = res;
	return resd;
}

/*
  Differentiation of subtract in forward (tangent) mode:
   variations   of useful results: *out
   with respect to varying inputs: *out *y
   Plus diff mem management of: out:in y:in
*/
// out = a - b
void subtract_d(int d, const double* const x, const double* const y, const
	double* const yd, double* out, double* outd) {
	for (int id = 0; id < d; ++id) {
		outd[id] = -yd[id];
		out[id] = x[id] - y[id];
	}
}

/*
  Differentiation of logsumexp in forward (tangent) mode:
   variations   of useful results: logsumexp
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
double logsumexp_d(int n, const double* const x, const double* const xd,
	double* logsumexp) {
	double mx;
	double mxd;
	mxd = arr_max_d(n, x, xd, &mx);
	double semx = 0.;
	double semxd;
	semxd = 0.0;
	for (int i = 0; i < n; ++i) {
		semxd = semxd + (xd[i] - mxd) * exp(x[i] - mx);
		semx = semx + exp(x[i] - mx);
	}
	*logsumexp = log(semx) + mx;
	return semxd / semx + mxd;
}

double log_gamma_distrib_c(double a, double p) {
	double out = 0.25 * p * (p - 1) * log(PI);
	float result1;
	int j;
	for (j = 1; j < p + 1; ++j) {
		result1 = lgamma(a + 0.5 * (1 - j));
		out = out + result1;
	}
	return out;
}

/*
  Differentiation of log_wishart_prior in forward (tangent) mode:
   variations   of useful results: log_wishart_prior
   with respect to varying inputs: *Qdiags *sum_qs *icf
   Plus diff mem management of: Qdiags:in sum_qs:in icf:in

 ========================================================================
								MAIN LOGIC
 ======================================================================== */
double log_wishart_prior_d(int p, int k, Wishart wishart, const double* const
	sum_qs, const double* const sum_qsd, const double* const Qdiags, const
	double* const Qdiagsd, const double* const icf, const double* const
	icfd, double* log_wishart_prior) {
	int n = p + wishart.m + 1;
	int icf_sz = p * (p + 1) / 2;
	double C;
	double result1;
	result1 = log_gamma_distrib_c(0.5 * n, p);
	C = n * p * (log(wishart.gamma) - 0.5 * log(2)) - result1;
	double out = 0;
	double outd;
	outd = 0.0;
	for (int ik = 0; ik < k; ++ik) {
		double frobenius;
		double frobeniusd;
		double result1;
		double result1d;
		double result2;
		double result2d;
		result1d = sqnorm_d(p, &(Qdiags[ik * p]), &(Qdiagsd[ik * p]), &result1);
		result2d = sqnorm_d(icf_sz - p, &(icf[ik * icf_sz + p]), &(icfd[ik *
			icf_sz + p]), &result2);
		frobeniusd = result1d + result2d;
		frobenius = result1 + result2;
		outd = outd + 0.5 * (wishart.gamma * wishart.gamma) * frobeniusd - wishart.m
			* sum_qsd[ik];
		out = out + 0.5 * wishart.gamma * wishart.gamma * frobenius - wishart.m *
			sum_qs[ik];
	}
	*log_wishart_prior = out - k * C;
	return outd;
}

/*
  Differentiation of preprocess_qs in forward (tangent) mode:
   variations   of useful results: *Qdiags *sum_qs
   with respect to varying inputs: *icf
   Plus diff mem management of: Qdiags:in sum_qs:in icf:in
*/
void preprocess_qs_d(int d, int k, const double* const icf, const double*
	const icfd, double* sum_qs, double* sum_qsd, double* Qdiags, double*
	Qdiagsd) {
	int icf_sz = d * (d + 1) / 2;
	*Qdiagsd = 0.0;
	*sum_qsd = 0.0;
	for (int ik = 0; ik < k; ++ik) {
		sum_qsd[ik] = 0.0;
		sum_qs[ik] = 0.;
		for (int id = 0; id < d; ++id) {
			double q = icf[ik * icf_sz + id];
			double qd = icfd[ik * icf_sz + id];
			sum_qsd[ik] = sum_qsd[ik] + qd;
			sum_qs[ik] = sum_qs[ik] + q;
			Qdiagsd[ik * d + id] = qd * exp(q);
			Qdiags[ik * d + id] = exp(q);
		}
	}
}

/*
  Differentiation of Qtimesx in forward (tangent) mode:
   variations   of useful results: *out
   with respect to varying inputs: *out *Qdiag *x *ltri
   Plus diff mem management of: out:in Qdiag:in x:in ltri:in
*/
void Qtimesx_d(int d, const double* const Qdiag, const double* const Qdiagd,
	const double* const ltri, const double* const ltrid, const double*
	const x, const double* const xd, double* out, double* outd) {
	// strictly lower triangular part
	;
	for (int id = 0; id < d; ++id) {
		outd[id] = Qdiagd[id] * x[id] + Qdiag[id] * xd[id];
		out[id] = Qdiag[id] * x[id];
	}
	int Lparamsidx = 0;
	for (int i = 0; i < d; ++i)
		for (int j = i + 1; j < d; ++j) {
			outd[j] = outd[j] + ltrid[Lparamsidx] * x[i] + ltri[Lparamsidx] * xd[i
			];
			out[j] = out[j] + ltri[Lparamsidx] * x[i];
			Lparamsidx++;
		}
}

/*
  Differentiation of gmm_objective in forward (tangent) mode:
   variations   of useful results: *err
   with respect to varying inputs: *means *icf *alphas
   RW status of diff variables: *err:out *means:in *icf:in *alphas:in
   Plus diff mem management of: err:in means:in icf:in alphas:in
*/
void gmm_objective_d(int d, int k, int n, const double* const alphas, const
	double* const alphasd, const double* const means, const double* const
	meansd, const double* const icf, const double* const icfd, const
	double* const x, Wishart wishart, double* err, double* errd) {
	const double CONSTANT = -n * d * 0.5 * log(2 * PI);
	int icf_sz = d * (d + 1) / 2;
	double* Qdiags;
	double* Qdiagsd;
	double result1;
	double result1d;
	Qdiagsd = (double*)malloc(d * k * sizeof(double));
	Qdiags = (double*)malloc(d * k * sizeof(double));
	double* sum_qs;
	double* sum_qsd;
	sum_qsd = (double*)malloc(k * sizeof(double));
	sum_qs = (double*)malloc(k * sizeof(double));
	double* xcentered;
	double* xcenteredd;
	xcenteredd = (double*)malloc(d * sizeof(double));
	xcentered = (double*)malloc(d * sizeof(double));
	double* Qxcentered;
	double* Qxcenteredd;
	Qxcenteredd = (double*)malloc(d * sizeof(double));
	Qxcentered = (double*)malloc(d * sizeof(double));
	double* main_term;
	double* main_termd;
	main_termd = (double*)malloc(k * sizeof(double));
	main_term = (double*)malloc(k * sizeof(double));
	preprocess_qs_d(d, k, icf, icfd, &(sum_qs[0]), &(sum_qsd[0]), &(Qdiags[0])
		, &(Qdiagsd[0]));
	double slse = 0.;
	double slsed;
	slsed = 0.0;
	for (int ix = 0; ix < n; ++ix) {
		for (int ik = 0; ik < k; ++ik) {
			subtract_d(d, &(x[ix * d]), &(means[ik * d]), &(meansd[ik * d]), &(
				xcentered[0]), &(xcenteredd[0]));
			Qtimesx_d(d, &(Qdiags[ik * d]), &(Qdiagsd[ik * d]), &(icf[ik * icf_sz +
				d]), &(icfd[ik * icf_sz + d]), &(xcentered[0]), &(
					xcenteredd[0]), &(Qxcentered[0]), &(Qxcenteredd[0]));
			result1d = sqnorm_d(d, &(Qxcentered[0]), &(Qxcenteredd[0]), &
				result1);
			main_termd[ik] = alphasd[ik] + sum_qsd[ik] - 0.5 * result1d;
			main_term[ik] = alphas[ik] + sum_qs[ik] - 0.5 * result1;
		}
		result1d = logsumexp_d(k, &(main_term[0]), &(main_termd[0]), &result1)
			;
		slsed = slsed + result1d;
		slse = slse + result1;
	}
	double lse_alphas;
	double lse_alphasd;
	lse_alphasd = logsumexp_d(k, alphas, alphasd, &lse_alphas);
	result1d = log_wishart_prior_d(d, k, wishart, &(sum_qs[0]), &(sum_qsd[0]),
		&(Qdiags[0]), &(Qdiagsd[0]), icf, icfd, &
		result1);
	*errd = slsed - n * lse_alphasd + result1d;
	*err = CONSTANT + slse - n * lse_alphas + result1;
	free(Qdiagsd);
	free(Qdiags);
	free(sum_qsd);
	free(sum_qs);
	free(xcenteredd);
	free(xcentered);
	free(Qxcenteredd);
	free(Qxcentered);
	free(main_termd);
	free(main_term);
}