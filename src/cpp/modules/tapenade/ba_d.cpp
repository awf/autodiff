/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.14 (r7259) - 18 Jan 2019 09:35
*/

#include "ba_d.h"

/*
  Differentiation of sqsum in forward (tangent) mode:
   variations   of useful results: sqsum
   with respect to varying inputs: *x
   Plus diff mem management of: x:in

 =====================================================================
                                UTILS
 ===================================================================== */
double sqsum_d(int n, const double* const x, const double* const xd, double*
    sqsum) {
    double res = 0;
    double resd;
    resd = 0.0;
    for (int i = 0; i < n; ++i) {
        resd = resd + xd[i] * x[i] + x[i] * xd[i];
        res = res + x[i] * x[i];
    }
    *sqsum = res;
    return resd;
}

/*
  Differentiation of cross in forward (tangent) mode:
   variations   of useful results: *out
   with respect to varying inputs: *a *b
   Plus diff mem management of: out:in a:in b:in
*/
void cross_d(const double* const a, const double* const ad, const double*
    const b, const double* const bd, double* out, double* outd) {
    outd[0] = ad[1] * b[2] + a[1] * bd[2] - ad[2] * b[1] - a[2] * bd[1];
    out[0] = a[1] * b[2] - a[2] * b[1];
    outd[1] = ad[2] * b[0] + a[2] * bd[0] - ad[0] * b[2] - a[0] * bd[2];
    out[1] = a[2] * b[0] - a[0] * b[2];
    outd[2] = ad[0] * b[1] + a[0] * bd[1] - ad[1] * b[0] - a[1] * bd[0];
    out[2] = a[0] * b[1] - a[1] * b[0];
}

/*
  Differentiation of rodrigues_rotate_point in forward (tangent) mode:
   variations   of useful results: *rotatedPt
   with respect to varying inputs: *rot *pt
   Plus diff mem management of: rot:in rotatedPt:in pt:in

 =====================================================================
                               MAIN LOGIC
 ===================================================================== */
 // rot: 3 rotation parameters
 // pt: 3 point to be rotated
 // rotatedPt: 3 rotated point
 // this is an efficient evaluation (part of
 // the Ceres implementation)
 // easy to understand calculation in matlab:
 //  theta = sqrt(sum(w. ^ 2));
 //  n = w / theta;
 //  n_x = au_cross_matrix(n);
 //  R = eye(3) + n_x*sin(theta) + n_x*n_x*(1 - cos(theta));    
void rodrigues_rotate_point_d(const double* const rot, const double* const
    rotd, const double* const pt, const double* const ptd, double*
    rotatedPt, double* rotatedPtd) {
    double sqtheta;
    double sqthetad;
    sqthetad = sqsum_d(3, rot, rotd, &sqtheta);
    if (sqtheta != 0) {
        double theta, costheta, sintheta, theta_inverse;
        double thetad, costhetad, sinthetad, theta_inversed;
        double w[3], w_cross_pt[3], tmp;
        double wd[3], w_cross_ptd[3], tmpd;
        int ii1;
        thetad = (sqtheta == 0.0 ? 0.0 : sqthetad / (2.0 * sqrt(sqtheta)));
        theta = sqrt(sqtheta);
        costhetad = -(thetad * sin(theta));
        costheta = cos(theta);
        sinthetad = thetad * cos(theta);
        sintheta = sin(theta);
        theta_inversed = -(thetad / (theta * theta));
        theta_inverse = 1.0 / theta;
        for (ii1 = 0; ii1 < 3; ++ii1)
            wd[ii1] = 0.0;
        for (int i = 0; i < 3; ++i) {
            wd[i] = rotd[i] * theta_inverse + rot[i] * theta_inversed;
            w[i] = rot[i] * theta_inverse;
        }
        cross_d(w, wd, pt, ptd, w_cross_pt, w_cross_ptd);
        tmpd = (wd[0] * pt[0] + w[0] * ptd[0] + wd[1] * pt[1] + w[1] * ptd[1] + wd[2] * pt[2] + w[
            2] * ptd[2]) * (1. - costheta) - (w[0] * pt[0] + w[1] * pt[1] + w[2] * pt[2]) *
                costhetad;
            tmp = (w[0] * pt[0] + w[1] * pt[1] + w[2] * pt[2]) * (1. - costheta);
            for (int i = 0; i < 3; ++i) {
                rotatedPtd[i] = ptd[i] * costheta + pt[i] * costhetad + w_cross_ptd[i]
                    * sintheta + w_cross_pt[i] * sinthetad + wd[i] * tmp + w[i] * tmpd;
                rotatedPt[i] = pt[i] * costheta + w_cross_pt[i] * sintheta + w[i] * tmp;
            }
    }
    else {
        double rot_cross_pt[3];
        double rot_cross_ptd[3];
        cross_d(rot, rotd, pt, ptd, rot_cross_pt, rot_cross_ptd);
        *rotatedPtd = 0.0;
        for (int i = 0; i < 3; ++i) {
            rotatedPtd[i] = ptd[i] + rot_cross_ptd[i];
            rotatedPt[i] = pt[i] + rot_cross_pt[i];
        }
    }
}

/*
  Differentiation of radial_distort in forward (tangent) mode:
   variations   of useful results: *proj
   with respect to varying inputs: *rad_params *proj
   Plus diff mem management of: rad_params:in proj:in
*/
void radial_distort_d(const double* const rad_params, const double* const
    rad_paramsd, double* proj, double* projd) {
    double rsq, L;
    double rsqd, Ld;
    rsqd = sqsum_d(2, proj, projd, &rsq);
    Ld = rad_paramsd[0] * rsq + rad_params[0] * rsqd + rad_paramsd[1] * (rsq * rsq) +
        rad_params[1] * (rsqd * rsq + rsq * rsqd);
    L = 1. + rad_params[0] * rsq + rad_params[1] * rsq * rsq;
    projd[0] = projd[0] * L + proj[0] * Ld;
    proj[0] = proj[0] * L;
    projd[1] = projd[1] * L + proj[1] * Ld;
    proj[1] = proj[1] * L;
}

/*
  Differentiation of project in forward (tangent) mode:
   variations   of useful results: *proj
   with respect to varying inputs: *cam *X
   Plus diff mem management of: cam:in X:in proj:in
*/
void project_d(const double* const cam, const double* const camd, const double
    * const X, const double* const Xd, double* proj, double* projd) {
    const const double* C = &(cam[3]);
    const double* Cd = &(camd[3]);
    double Xo[3], Xcam[3];
    double Xod[3], Xcamd[3];
    int ii1;
    for (ii1 = 0; ii1 < 3; ++ii1)
        Xod[ii1] = 0.0;
    Xod[0] = Xd[0] - Cd[0];
    Xo[0] = X[0] - C[0];
    Xod[1] = Xd[1] - Cd[1];
    Xo[1] = X[1] - C[1];
    Xod[2] = Xd[2] - Cd[2];
    Xo[2] = X[2] - C[2];
    rodrigues_rotate_point_d(&(cam[0]), &(camd[0]), Xo, Xod, Xcam, Xcamd);
    projd[0] = (Xcamd[0] * Xcam[2] - Xcam[0] * Xcamd[2]) / (Xcam[2] * Xcam[2]);
    proj[0] = Xcam[0] / Xcam[2];
    projd[1] = (Xcamd[1] * Xcam[2] - Xcam[1] * Xcamd[2]) / (Xcam[2] * Xcam[2]);
    proj[1] = Xcam[1] / Xcam[2];
    radial_distort_d(&(cam[9]), &(camd[9]), proj, projd);
    projd[0] = projd[0] * cam[6] + proj[0] * camd[6] + camd[7];
    proj[0] = proj[0] * cam[6] + cam[7];
    projd[1] = projd[1] * cam[6] + proj[1] * camd[6] + camd[8];
    proj[1] = proj[1] * cam[6] + cam[8];
}

/*
  Differentiation of compute_reproj_error in forward (tangent) mode:
   variations   of useful results: *err
   with respect to varying inputs: *w *cam *X
   RW status of diff variables: *err:out *w:in *cam:in *X:in
   Plus diff mem management of: err:in w:in cam:in X:in
*/
// cam: 11 camera in format [r1 r2 r3 C1 C2 C3 f u0 v0 k1 k2]
//            r1, r2, r3 are angle - axis rotation parameters(Rodrigues)
//            [C1 C2 C3]' is the camera center
//            f is the focal length in pixels
//            [u0 v0]' is the principal point
//            k1, k2 are radial distortion parameters
// X: 3 point
// feats: 2 feature (x,y coordinates)
// reproj_err: 2
// projection function: 
// Xcam = R * (X - C)
// distorted = radial_distort(projective2euclidean(Xcam), radial_parameters)
// proj = distorted * f + principal_point
// err = sqsum(proj - measurement)
void compute_reproj_error_d(const double* const cam, const double* const camd,
    const double* const X, const double* const Xd, const double* const w,
    const double* const wd, const double* const feat, double* err, double
    * errd) {
    double proj[2];
    double projd[2];
    project_d(cam, camd, X, Xd, proj, projd);
    errd[0] = (*wd) * (proj[0] - feat[0]) + (*w) * projd[0];
    err[0] = (*w) * (proj[0] - feat[0]);
    errd[1] = (*wd) * (proj[1] - feat[1]) + (*w) * projd[1];
    err[1] = (*w) * (proj[1] - feat[1]);
}

/*
  Differentiation of compute_zach_weight_error in forward (tangent) mode:
   variations   of useful results: *err
   with respect to varying inputs: *w
   RW status of diff variables: *err:out *w:in
   Plus diff mem management of: err:in w:in
*/
void compute_zach_weight_error_d(const double* const w, const double* const wd
    , double* err, double* errd) {
    *errd = -((*wd) * (*w)) - (*w) * (*wd);
    *err = 1 - (*w) * (*w);
}
