% Copyright (c) Microsoft Corporation.
% Licensed under the MIT license.

% Generated by ADiMat 0.6.0-4975
% © 2001-2008 Andre Vehreschild <vehreschild@sc.rwth-aachen.de>
% © 2009-2015 Johannes Willkomm <johannes@johannes-willkomm.de>
% TU Darmstadt, 64289 Darmstadt, Germany
% Visit us on the web at http://www.adimat.de/
% Report bugs to adimat-users@lists.sc.informatik.tu-darmstadt.de
%
%                             DISCLAIMER
% 
% ADiMat was prepared as part of an employment at the Institute for Scientific Computing,
% RWTH Aachen University, Germany and at the Institute for Scientific Computing,
% TU Darmstadt, Germany and is provided AS IS. 
% NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL REPUBLIC OF GERMANY
% NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY, NOT THE TU DARMSTADT,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY, EXPRESS OR IMPLIED,
% OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS,
% OR USEFULNESS OF ANY INFORMATION OR PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE
% WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS.
%
% Parameters:
%  - dependents=err
%  - independents=alphas, means, inv_cov_factors
%  - inputEncoding=ISO-8859-1
%
% Functions in this file: d_gmm_objective, d_sqnorm,
%  sqnorm, d_log_wishart_prior, log_wishart_prior,
%  log_gamma_distrib, d_logsumexp
%

function [d_err err] = d_gmm_objective(d_alphas, alphas, d_means, means, d_inv_cov_factors, inv_cov_factors, x, hparams)
% GMM_OBJECTIVE  Evaluate GMM negative log likelihood for one point
%             ALPHAS 
%                1 x k vector of logs of mixture weights (unnormalized), so
%                weights = exp(log_alphas)/sum(exp(log_alphas))
%             MEANS
%                d x k matrix of component means
%             INV_COV_FACTORS 
%                (d*(d+1)/2) x k matrix, parametrizing 
%                lower triangular square roots of inverse covariances
%                log of diagonal is first d params
%             X 
%               are data points (d x n vector)
%             HPARAMS
%                [gamma, m] wishart distribution parameters
%         Output ERR is the sum of errors over all points
%      To generate params given covariance C:
%           L = inv(chol(C,'lower'));
%           inv_cov_factor = [log(diag(L)); L(au_tril_indices(d,-1))]
   icf = [];
   d_icf = d_zeros(icf);
   logLdiag = [];
   d_logLdiag = d_zeros(logLdiag);
   main_term = [];
   d_main_term = d_zeros(main_term);
   Qxcentered = [];
   d_Qxcentered = d_zeros(Qxcentered);
   d = size(x, 1);
   k = size(alphas, 2);
   n = size(x, 2);
   lower_triangle_indices = tril(ones(d, d), -1) ~= 0;
   d_sum_qs = adimat_diff_sum2(adimat_opdiff_subsref(d_inv_cov_factors, struct('type', '()', 'subs', {{1 : d ':'}})), inv_cov_factors(1 : d, :), 1);
   sum_qs = sum(inv_cov_factors(1 : d, :), 1);
   Qs = cell(1, k);
   d_Qs = d_zeros(Qs);
   Qdiags = zeros(d, k);
   d_Qdiags = d_zeros(Qdiags);
   for ik=1 : k
      d_icf = adimat_opdiff_subsref(d_inv_cov_factors, struct('type', '()', 'subs', {{':' ik}}));
      icf = inv_cov_factors(:, ik);
      d_logLdiag = adimat_opdiff_subsref(d_icf, struct('type', '()', 'subs', {{1 : d}}));
      logLdiag = icf(1 : d);
      [tmpada1 Qdiags(:, ik)] = adimat_diff_exp(d_logLdiag, logLdiag);
      d_Qdiags = adimat_opdiff_subsasgn(d_Qdiags, struct('type', {'()'}, 'subs', {{':' ik}}), tmpada1);
      [tmpada1 Qs{ik}] = adimat_diff_diag(adimat_opdiff_subsref(d_Qdiags, struct('type', '()', 'subs', {{':' ik}})), Qdiags(:, ik));
      d_Qs = adimat_opdiff_subsasgn(d_Qs, struct('type', {'{}'}, 'subs', {{ik}}), tmpada1);
      tmpda1 = d + 1;
      d_Qs = adimat_opdiff_subsasgn(d_Qs, struct('type', {'{}' '()'}, 'subs', {{ik} {lower_triangle_indices}}), adimat_opdiff_subsref(d_icf, struct('type', '()', 'subs', {{tmpda1 : adimat_end(icf, 1, 1)}})));
      Qs{ik}(lower_triangle_indices) = icf(tmpda1 : end);
   end
   slse = 0;
   d_slse = d_zeros(slse);
   for ix=1 : n
      main_term = zeros(1, k);
      d_main_term = d_zeros(main_term);
      for ik=1 : k
         d_tmpca1 = adimat_opdiff_sum(-adimat_opdiff_subsref(d_means, struct('type', '()', 'subs', {{':' ik}})), d_zeros(x(:, ix)));
         tmpca1 = x(:, ix) - means(:, ik);
         d_Qxcentered = adimat_opdiff_mult(d_Qs{ik}, Qs{ik}, d_tmpca1, tmpca1);
         Qxcentered = Qs{ik} * tmpca1;
         [d_tmpca1 tmpca1] = d_sqnorm(d_Qxcentered, Qxcentered);
         d_main_term = adimat_opdiff_subsasgn(d_main_term, struct('type', {'()'}, 'subs', {{ik}}), adimat_opdiff_mult_left(-0.5, d_tmpca1, tmpca1));
         main_term(ik) = -0.5 * tmpca1;
      end
      d_main_term = adimat_opdiff_sum(d_main_term, d_alphas, d_sum_qs);
      main_term = main_term + alphas + sum_qs;
      [d_tmpca1 tmpca1] = d_logsumexp(d_main_term, main_term);
      d_slse = adimat_opdiff_sum(d_slse, d_tmpca1);
      slse = slse + tmpca1;
   end
   constant = -n * d * 0.5 * log(2 * pi);
   [d_tmpca2 tmpca2] = d_logsumexp(d_alphas, alphas);
   d_tmpca1 = adimat_opdiff_mult_left(n, d_tmpca2, tmpca2);
   tmpca1 = n * tmpca2;
   d_err = adimat_opdiff_sum(d_slse, -d_tmpca1, d_zeros(constant));
   err = constant + slse - tmpca1;
   [d_tmpca1 tmpca1] = d_log_wishart_prior(hparams, d, d_sum_qs, sum_qs, d_Qdiags, Qdiags, d_inv_cov_factors, inv_cov_factors);
   d_err = adimat_opdiff_sum(d_err, d_tmpca1);
   err = err + tmpca1;
end

function [d_out out] = d_sqnorm(d_x, x)
   d_tmpca1 = adimat_opdiff_epow_right(d_x, x, 2);
   tmpca1 = x .^ 2;
   d_out = adimat_diff_sum2(d_tmpca1, tmpca1, 1);
   out = sum(tmpca1, 1);
end

function out = sqnorm(x)
   tmpca1 = x .^ 2;
   out = sum(tmpca1, 1);
end

function [d_out out] = d_log_wishart_prior(hparams, p, d_sum_qs, sum_qs, d_Qdiags, Qdiags, d_inv_cov_factors, inv_cov_factors)
% LOG_WISHART_PRIOR  
%               HPARAMS = [gamma m]
%               P data dimension
%             INV_COV_FACTORS
%                (d*(d+1)/2) x k matrix, parametrizing 
%                lower triangular square roots of inverse covariances
%                log of diagonal is first d params
   gamma = hparams(1);
   m = hparams(2);
   n = p + m + 1;
   tmpda6 = p + 1;
   [d_tmpca5 tmpca5] = d_sqnorm(adimat_opdiff_subsref(d_inv_cov_factors, struct('type', '()', 'subs', {{tmpda6 : adimat_end(inv_cov_factors, 1, 2) ':'}})), inv_cov_factors(tmpda6 : end, :));
   [d_tmpca4 tmpca4] = d_sqnorm(d_Qdiags, Qdiags);
   d_tmpca3 = adimat_opdiff_sum(d_tmpca4, d_tmpca5);
   tmpca3 = tmpca4 + tmpca5;
   tmpda2 = gamma ^ 2;
   tmpda1 = 0.5 * tmpda2;
   d_term1 = adimat_opdiff_mult_left(tmpda1, d_tmpca3, tmpca3);
   term1 = tmpda1 * tmpca3;
   d_term2 = adimat_opdiff_mult_left(m, d_sum_qs, sum_qs);
   term2 = m * sum_qs;
   C = n*p*(log(gamma) - 0.5*log(2)) - log_gamma_distrib(0.5 * n, p);
   d_tmpca1 = adimat_opdiff_sum(d_term1, -d_term2, d_zeros(-C));
   tmpca1 = term1 - term2 - C;
   d_out = adimat_diff_sum1(d_tmpca1, tmpca1);
   out = sum(tmpca1);
end

function out = log_wishart_prior(hparams, p, sum_qs, Qdiags, inv_cov_factors)
% LOG_WISHART_PRIOR  
%               HPARAMS = [gamma m]
%               P data dimension
%             INV_COV_FACTORS
%                (d*(d+1)/2) x k matrix, parametrizing 
%                lower triangular square roots of inverse covariances
%                log of diagonal is first d params
   gamma = hparams(1);
   m = hparams(2);
   n = p + m + 1;
   tmpda6 = p + 1;
   tmpca5 = sqnorm(inv_cov_factors(tmpda6 : end, :));
   tmpca4 = sqnorm(Qdiags);
   tmpca3 = tmpca4 + tmpca5;
   tmpda2 = gamma ^ 2;
   tmpda1 = 0.5 * tmpda2;
   term1 = tmpda1 * tmpca3;
   term2 = m * sum_qs;
   C = n*p*(log(gamma) - 0.5*log(2)) - log_gamma_distrib(0.5 * n, p);
   tmpca1 = term1 - term2 - C;
   out = sum(tmpca1);
end

function out = log_gamma_distrib(a, p)
   out = 0.25 * p * (p - 1) * log(pi);
   for j=1 : p
      out = out + gammaln(a + 0.5*(1 - j));
   end
end

function [d_out out] = d_logsumexp(d_x, x)
% LOGSUMEXP  Compute log(sum(exp(x))) stably.
%               X is k x n
%               OUT is 1 x n
   [d_mx mx] = adimat_diff_max1(d_x, x);
   d_tmpca1 = adimat_opdiff_sum(d_x, -d_mx);
   tmpca1 = x - mx;
   [d_emx emx] = adimat_diff_exp(d_tmpca1, tmpca1);
   d_semx = adimat_diff_sum1(d_emx, emx);
   semx = sum(emx);
   [d_tmpca1 tmpca1] = adimat_diff_log(d_semx, semx);
   d_out = adimat_opdiff_sum(d_tmpca1, d_mx);
   out = tmpca1 + mx;
end
