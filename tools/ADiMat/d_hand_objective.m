% Copyright (c) Microsoft Corporation.
% Licensed under the MIT license.

% Generated by ADiMat 0.6.0-4975
% © 2001-2008 Andre Vehreschild <vehreschild@sc.rwth-aachen.de>
% © 2009-2015 Johannes Willkomm <johannes@johannes-willkomm.de>
% TU Darmstadt, 64289 Darmstadt, Germany
% Visit us on the web at http://www.adimat.de/
% Report bugs to adimat-users@lists.sc.informatik.tu-darmstadt.de
%
%                             DISCLAIMER
% 
% ADiMat was prepared as part of an employment at the Institute for Scientific Computing,
% RWTH Aachen University, Germany and at the Institute for Scientific Computing,
% TU Darmstadt, Germany and is provided AS IS. 
% NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL REPUBLIC OF GERMANY
% NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY, NOT THE TU DARMSTADT,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY, EXPRESS OR IMPLIED,
% OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS,
% OR USEFULNESS OF ANY INFORMATION OR PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE
% WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS.
%
% Parameters:
%  - dependents=err
%  - independents=params
%  - inputEncoding=ISO-8859-1
%
% Functions in this file: d_hand_objective, d_to_pose_params,
%  d_get_skinned_vertex_positions, d_apply_global_transform, apply_global_transform,
%  d_angle_axis_to_rotation_matrix, angle_axis_to_rotation_matrix, d_relatives_to_absolutes,
%  relatives_to_absolutes, d_get_posed_relatives, get_posed_relatives,
%  d_euler_angles_to_rotation_matrix, euler_angles_to_rotation_matrix
%

function [d_err err] = d_hand_objective(d_params, params, data)
%HAND_OBJECTIVE 
   tmpda1 = size(data.model.bone_names, 1);
   [d_pose_params pose_params] = d_to_pose_params(d_params, params, tmpda1);
   [d_vertex_positions vertex_positions] = d_get_skinned_vertex_positions(data.model, d_pose_params, pose_params);
   n_corr = numel(data.correspondences);
   err = zeros(3, n_corr);
   d_err = d_zeros(err);
   for i=1 : n_corr
      d_err = adimat_opdiff_subsasgn(d_err, struct('type', {'()'}, 'subs', {{':' i}}), adimat_opdiff_sum(-adimat_opdiff_subsref(d_vertex_positions, struct('type', '()', 'subs', {{':' data.correspondences(i)}})), d_zeros(data.points(:, i))));
      err(:, i) = data.points(:, i) - vertex_positions(:, data.correspondences(i));
   end
end

function [d_pose_params pose_params] = d_to_pose_params(d_theta, theta, n_bones)
% to_pose_params !!!!!!!!!!!!!!! fixed order pose_params !!!!!
%       1) global_rotation 2) scale 3) global_translation
%       4) wrist
%       5) thumb1, 6)thumb2, 7) thumb3, 8) thumb4
%       similarly: index, middle, ring, pinky
%       end) forearm
   i = [];
   n = 3 + n_bones;
   pose_params = zeros(3, n);
   d_pose_params = d_zeros(pose_params);
   d_pose_params = adimat_opdiff_subsasgn(d_pose_params, struct('type', {'()'}, 'subs', {{':' 1}}), adimat_opdiff_subsref(d_theta, struct('type', '()', 'subs', {{1 : 3}})));
   pose_params(:, 1) = theta(1 : 3);
   tmpva1 = 1;
   pose_params(:, 2) = tmpva1;
   d_pose_params = adimat_opdiff_subsasgn(d_pose_params, struct('type', {'()'}, 'subs', {{':' 2}}), d_zeros(tmpva1));
   d_pose_params = adimat_opdiff_subsasgn(d_pose_params, struct('type', {'()'}, 'subs', {{':' 3}}), adimat_opdiff_subsref(d_theta, struct('type', '()', 'subs', {{4 : 6}})));
   pose_params(:, 3) = theta(4 : 6);
   i_theta = 7;
   i_pose_params = 6;
   n_fingers = 5;
   for finger=1 : n_fingers
      for i=[2 3 4]
         d_pose_params = adimat_opdiff_subsasgn(d_pose_params, struct('type', {'()'}, 'subs', {{1 i_pose_params}}), adimat_opdiff_subsref(d_theta, struct('type', '()', 'subs', {{i_theta}})));
         pose_params(1, i_pose_params) = theta(i_theta);
         i_theta = i_theta + 1;
         if i == 2
            d_pose_params = adimat_opdiff_subsasgn(d_pose_params, struct('type', {'()'}, 'subs', {{2 i_pose_params}}), adimat_opdiff_subsref(d_theta, struct('type', '()', 'subs', {{i_theta}})));
            pose_params(2, i_pose_params) = theta(i_theta);
            i_theta = i_theta + 1;
         end
         i_pose_params = i_pose_params + 1;
      end
      i_pose_params = i_pose_params + 1;
   end
end

function [d_positions positions] = d_get_skinned_vertex_positions(model, d_pose_params, pose_params)
   [d_relatives relatives] = d_get_posed_relatives(model, d_pose_params, pose_params);
   [d_absolutes absolutes] = d_relatives_to_absolutes(d_relatives, relatives, model.parents);
   tmpda1 = size(absolutes);
   transforms = zeros(tmpda1);
   d_transforms = d_zeros(transforms);
   for i=1 : size(transforms, 1)
      tmpda2 = squeeze(model.inverse_base_transforms(i, :, :));
      [d_tmpca1 tmpca1] = adimat_diff_squeeze(adimat_opdiff_subsref(d_absolutes, struct('type', '()', 'subs', {{i ':' ':'}})), absolutes(i, :, :));
      d_transforms = adimat_opdiff_subsasgn(d_transforms, struct('type', {'()'}, 'subs', {{i ':' ':'}}), adimat_opdiff_mult_right(d_tmpca1, tmpca1, tmpda2));
      transforms(i, :, :) = tmpca1 * tmpda2;
   end
   n_verts = size(model.base_positions, 2);
   positions = zeros(3, n_verts);
   d_positions = d_zeros(positions);
   for i=1 : size(transforms, 1)
      tmpda4 = repmat(model.weights(i, :), 3, 1);
      [d_tmpca3 tmpca3] = adimat_diff_squeeze(adimat_opdiff_subsref(d_transforms, struct('type', '()', 'subs', {{i 1 : 3 ':'}})), transforms(i, 1 : 3, :));
      d_tmpca2 = adimat_opdiff_mult_right(d_tmpca3, tmpca3, model.base_positions);
      tmpca2 = tmpca3 * model.base_positions;
      d_tmpca1 = adimat_opdiff_emult_right(d_tmpca2, tmpca2, tmpda4);
      tmpca1 = tmpca2 .* tmpda4;
      d_positions = adimat_opdiff_sum(d_positions, d_tmpca1);
      positions = positions + tmpca1;
   end
   if model.is_mirrored
      d_positions = adimat_opdiff_subsasgn(d_positions, struct('type', {'()'}, 'subs', {{1 ':'}}), -adimat_opdiff_subsref(d_positions, struct('type', '()', 'subs', {{1 ':'}})));
      positions(1, :) = -positions(1, :);
   end
   apply_global = true;
   if apply_global
      [d_positions positions] = d_apply_global_transform(d_pose_params, pose_params, d_positions, positions);
   end
end

function [d_positions positions] = d_apply_global_transform(d_pose_params, pose_params, d_positions, positions)
   T = eye(3, 4);
   d_T = d_zeros(T);
   [tmpada1 T(:, 1 : 3)] = d_angle_axis_to_rotation_matrix(adimat_opdiff_subsref(d_pose_params, struct('type', '()', 'subs', {{':' 1}})), pose_params(:, 1));
   d_T = adimat_opdiff_subsasgn(d_T, struct('type', {'()'}, 'subs', {{':' 1 : 3}}), tmpada1);
   d_tmpca1 = adimat_diff_repmat2(adimat_opdiff_trans(adimat_opdiff_subsref(d_pose_params, struct('type', '()', 'subs', {{':' 2}})), pose_params(:, 2)), pose_params(:, 2)', 3, 1);
   tmpca1 = repmat(pose_params(:, 2)', 3, 1);
   d_T = adimat_opdiff_subsasgn(d_T, struct('type', {'()'}, 'subs', {{':' 1 : 3}}), adimat_opdiff_emult(adimat_opdiff_subsref(d_T, struct('type', '()', 'subs', {{1 : 3 1 : 3}})), T(1 : 3, 1 : 3), d_tmpca1, tmpca1));
   T(:, 1 : 3) = T(1 : 3, 1 : 3) .* tmpca1;
   d_T = adimat_opdiff_subsasgn(d_T, struct('type', {'()'}, 'subs', {{':' 4}}), adimat_opdiff_subsref(d_pose_params, struct('type', '()', 'subs', {{':' 3}})));
   T(:, 4) = pose_params(:, 3);
   tmpda2 = size(positions, 2);
   tmpda1 = ones(1, tmpda2);
   d_positions = adimat_opdiff_mult(d_T, T, adimat_fdiff_cat(2, adimat_fdiff_cat(3, d_positions), adimat_fdiff_cat(3, d_zeros(tmpda1))), [positions
                            tmpda1]);
   positions = T * [positions
         tmpda1];
end

function positions = apply_global_transform(pose_params, positions)
   T = eye(3, 4);
   T(:, 1 : 3) = angle_axis_to_rotation_matrix(pose_params(:, 1));
   tmpca1 = repmat(pose_params(:, 2)', 3, 1);
   T(:, 1 : 3) = T(1 : 3, 1 : 3) .* tmpca1;
   T(:, 4) = pose_params(:, 3);
   tmpda2 = size(positions, 2);
   tmpda1 = ones(1, tmpda2);
   positions = T * [positions
         tmpda1];
end

function [d_R R] = d_angle_axis_to_rotation_matrix(d_angle_axis, angle_axis)
   R = [];
   d_R = d_zeros(R);
   d_tmpca2 = adimat_opdiff_epow_right(d_angle_axis, angle_axis, 2);
   tmpca2 = angle_axis .^ 2;
   d_tmpca1 = adimat_diff_sum1(d_tmpca2, tmpca2);
   tmpca1 = sum(tmpca2);
   [d_n n] = adimat_diff_sqrt(d_tmpca1, tmpca1);
   if n < .0001
      R = eye(3);
      d_R = d_zeros(R);
      return
   end
   d_x = adimat_opdiff_div(adimat_opdiff_subsref(d_angle_axis, struct('type', '()', 'subs', {{1}})), angle_axis(1), d_n, n);
   x = angle_axis(1) / n;
   d_y = adimat_opdiff_div(adimat_opdiff_subsref(d_angle_axis, struct('type', '()', 'subs', {{2}})), angle_axis(2), d_n, n);
   y = angle_axis(2) / n;
   d_z = adimat_opdiff_div(adimat_opdiff_subsref(d_angle_axis, struct('type', '()', 'subs', {{3}})), angle_axis(3), d_n, n);
   z = angle_axis(3) / n;
   [d_s s] = adimat_diff_sin(d_n, n);
   [d_c c] = adimat_diff_cos(d_n, n);
   d_tmpca45 = adimat_opdiff_mult(d_z, z, d_z, z);
   tmpca45 = z * z;
   d_tmpca44 = adimat_opdiff_sum(-d_tmpca45, d_zeros(1));
   tmpca44 = 1 - tmpca45;
   d_tmpca43 = adimat_opdiff_mult(d_tmpca44, tmpca44, d_c, c);
   tmpca43 = tmpca44 * c;
   d_tmpca42 = adimat_opdiff_mult(d_z, z, d_z, z);
   tmpca42 = z * z;
   d_tmpca41 = adimat_opdiff_sum(d_tmpca42, d_tmpca43);
   tmpca41 = tmpca42 + tmpca43;
   d_tmpca40 = adimat_opdiff_mult(d_x, x, d_s, s);
   tmpca40 = x * s;
   d_tmpca39 = adimat_opdiff_sum(-d_c, d_zeros(1));
   tmpca39 = 1 - c;
   d_tmpca38 = adimat_opdiff_mult(d_z, z, d_y, y);
   tmpca38 = z * y;
   d_tmpca37 = adimat_opdiff_mult(d_tmpca38, tmpca38, d_tmpca39, tmpca39);
   tmpca37 = tmpca38 * tmpca39;
   d_tmpca36 = adimat_opdiff_sum(d_tmpca37, d_tmpca40);
   tmpca36 = tmpca37 + tmpca40;
   d_tmpca35 = adimat_opdiff_mult(d_y, y, d_s, s);
   tmpca35 = y * s;
   d_tmpca34 = adimat_opdiff_sum(-d_c, d_zeros(1));
   tmpca34 = 1 - c;
   d_tmpca33 = adimat_opdiff_mult(d_x, x, d_z, z);
   tmpca33 = x * z;
   d_tmpca32 = adimat_opdiff_mult(d_tmpca33, tmpca33, d_tmpca34, tmpca34);
   tmpca32 = tmpca33 * tmpca34;
   d_tmpca31 = adimat_opdiff_sum(d_tmpca32, -d_tmpca35);
   tmpca31 = tmpca32 - tmpca35;
   d_tmpca30 = adimat_opdiff_mult(d_x, x, d_s, s);
   tmpca30 = x * s;
   d_tmpca29 = adimat_opdiff_sum(-d_c, d_zeros(1));
   tmpca29 = 1 - c;
   d_tmpca28 = adimat_opdiff_mult(d_y, y, d_z, z);
   tmpca28 = y * z;
   d_tmpca27 = adimat_opdiff_mult(d_tmpca28, tmpca28, d_tmpca29, tmpca29);
   tmpca27 = tmpca28 * tmpca29;
   d_tmpca26 = adimat_opdiff_sum(d_tmpca27, -d_tmpca30);
   tmpca26 = tmpca27 - tmpca30;
   d_tmpca25 = adimat_opdiff_mult(d_y, y, d_y, y);
   tmpca25 = y * y;
   d_tmpca24 = adimat_opdiff_sum(-d_tmpca25, d_zeros(1));
   tmpca24 = 1 - tmpca25;
   d_tmpca23 = adimat_opdiff_mult(d_tmpca24, tmpca24, d_c, c);
   tmpca23 = tmpca24 * c;
   d_tmpca22 = adimat_opdiff_mult(d_y, y, d_y, y);
   tmpca22 = y * y;
   d_tmpca21 = adimat_opdiff_sum(d_tmpca22, d_tmpca23);
   tmpca21 = tmpca22 + tmpca23;
   d_tmpca20 = adimat_opdiff_mult(d_z, z, d_s, s);
   tmpca20 = z * s;
   d_tmpca19 = adimat_opdiff_sum(-d_c, d_zeros(1));
   tmpca19 = 1 - c;
   d_tmpca18 = adimat_opdiff_mult(d_x, x, d_y, y);
   tmpca18 = x * y;
   d_tmpca17 = adimat_opdiff_mult(d_tmpca18, tmpca18, d_tmpca19, tmpca19);
   tmpca17 = tmpca18 * tmpca19;
   d_tmpca16 = adimat_opdiff_sum(d_tmpca17, d_tmpca20);
   tmpca16 = tmpca17 + tmpca20;
   d_tmpca15 = adimat_opdiff_mult(d_y, y, d_s, s);
   tmpca15 = y * s;
   d_tmpca14 = adimat_opdiff_sum(-d_c, d_zeros(1));
   tmpca14 = 1 - c;
   d_tmpca13 = adimat_opdiff_mult(d_x, x, d_z, z);
   tmpca13 = x * z;
   d_tmpca12 = adimat_opdiff_mult(d_tmpca13, tmpca13, d_tmpca14, tmpca14);
   tmpca12 = tmpca13 * tmpca14;
   d_tmpca11 = adimat_opdiff_sum(d_tmpca12, d_tmpca15);
   tmpca11 = tmpca12 + tmpca15;
   d_tmpca10 = adimat_opdiff_mult(d_z, z, d_s, s);
   tmpca10 = z * s;
   d_tmpca9 = adimat_opdiff_sum(-d_c, d_zeros(1));
   tmpca9 = 1 - c;
   d_tmpca8 = adimat_opdiff_mult(d_x, x, d_y, y);
   tmpca8 = x * y;
   d_tmpca7 = adimat_opdiff_mult(d_tmpca8, tmpca8, d_tmpca9, tmpca9);
   tmpca7 = tmpca8 * tmpca9;
   d_tmpca6 = adimat_opdiff_sum(d_tmpca7, -d_tmpca10);
   tmpca6 = tmpca7 - tmpca10;
   d_tmpca5 = adimat_opdiff_mult(d_x, x, d_x, x);
   tmpca5 = x * x;
   d_tmpca4 = adimat_opdiff_sum(-d_tmpca5, d_zeros(1));
   tmpca4 = 1 - tmpca5;
   d_tmpca3 = adimat_opdiff_mult(d_tmpca4, tmpca4, d_c, c);
   tmpca3 = tmpca4 * c;
   d_tmpca2 = adimat_opdiff_mult(d_x, x, d_x, x);
   tmpca2 = x * x;
   d_tmpca1 = adimat_opdiff_sum(d_tmpca2, d_tmpca3);
   tmpca1 = tmpca2 + tmpca3;
   d_R = adimat_fdiff_cat(2, adimat_fdiff_cat(3, d_tmpca1, d_tmpca6, d_tmpca11), adimat_fdiff_cat(3), adimat_fdiff_cat(3, d_tmpca16, d_tmpca21, d_tmpca26), adimat_fdiff_cat(3), adimat_fdiff_cat(3, d_tmpca31, d_tmpca36, d_tmpca41));
   R = [tmpca1 tmpca6 tmpca11
         
         tmpca16 tmpca21 tmpca26
         
         tmpca31 tmpca36 tmpca41];
end

function R = angle_axis_to_rotation_matrix(angle_axis)
   R = [];
   tmpca2 = angle_axis .^ 2;
   tmpca1 = sum(tmpca2);
   n = sqrt(tmpca1);
   if n < .0001
      R = eye(3);
      return
   end
   x = angle_axis(1) / n;
   y = angle_axis(2) / n;
   z = angle_axis(3) / n;
   s = sin(n);
   c = cos(n);
   tmpca45 = z * z;
   tmpca44 = 1 - tmpca45;
   tmpca43 = tmpca44 * c;
   tmpca42 = z * z;
   tmpca41 = tmpca42 + tmpca43;
   tmpca40 = x * s;
   tmpca39 = 1 - c;
   tmpca38 = z * y;
   tmpca37 = tmpca38 * tmpca39;
   tmpca36 = tmpca37 + tmpca40;
   tmpca35 = y * s;
   tmpca34 = 1 - c;
   tmpca33 = x * z;
   tmpca32 = tmpca33 * tmpca34;
   tmpca31 = tmpca32 - tmpca35;
   tmpca30 = x * s;
   tmpca29 = 1 - c;
   tmpca28 = y * z;
   tmpca27 = tmpca28 * tmpca29;
   tmpca26 = tmpca27 - tmpca30;
   tmpca25 = y * y;
   tmpca24 = 1 - tmpca25;
   tmpca23 = tmpca24 * c;
   tmpca22 = y * y;
   tmpca21 = tmpca22 + tmpca23;
   tmpca20 = z * s;
   tmpca19 = 1 - c;
   tmpca18 = x * y;
   tmpca17 = tmpca18 * tmpca19;
   tmpca16 = tmpca17 + tmpca20;
   tmpca15 = y * s;
   tmpca14 = 1 - c;
   tmpca13 = x * z;
   tmpca12 = tmpca13 * tmpca14;
   tmpca11 = tmpca12 + tmpca15;
   tmpca10 = z * s;
   tmpca9 = 1 - c;
   tmpca8 = x * y;
   tmpca7 = tmpca8 * tmpca9;
   tmpca6 = tmpca7 - tmpca10;
   tmpca5 = x * x;
   tmpca4 = 1 - tmpca5;
   tmpca3 = tmpca4 * c;
   tmpca2 = x * x;
   tmpca1 = tmpca2 + tmpca3;
   R = [tmpca1 tmpca6 tmpca11
         
         tmpca16 tmpca21 tmpca26
         
         tmpca31 tmpca36 tmpca41];
end

function [d_absolutes absolutes] = d_relatives_to_absolutes(d_relatives, relatives, parents)
   tmpda1 = size(relatives);
   absolutes = zeros(tmpda1);
   d_absolutes = d_zeros(absolutes);
   for i=1 : numel(parents)
      if parents(i) == 0
         d_absolutes = adimat_opdiff_subsasgn(d_absolutes, struct('type', {'()'}, 'subs', {{i ':' ':'}}), adimat_opdiff_subsref(d_relatives, struct('type', '()', 'subs', {{i ':' ':'}})));
         absolutes(i, :, :) = relatives(i, :, :);
      else
         [d_tmpca2 tmpca2] = adimat_diff_squeeze(adimat_opdiff_subsref(d_relatives, struct('type', '()', 'subs', {{i ':' ':'}})), relatives(i, :, :));
         [d_tmpca1 tmpca1] = adimat_diff_squeeze(adimat_opdiff_subsref(d_absolutes, struct('type', '()', 'subs', {{parents(i) ':' ':'}})), absolutes(parents(i), :, :));
         d_absolutes = adimat_opdiff_subsasgn(d_absolutes, struct('type', {'()'}, 'subs', {{i ':' ':'}}), adimat_opdiff_mult(d_tmpca1, tmpca1, d_tmpca2, tmpca2));
         absolutes(i, :, :) = tmpca1 * tmpca2;
      end
   end
end

function absolutes = relatives_to_absolutes(relatives, parents)
   tmpda1 = size(relatives);
   absolutes = zeros(tmpda1);
   for i=1 : numel(parents)
      if parents(i) == 0
         absolutes(i, :, :) = relatives(i, :, :);
      else
         tmpca2 = squeeze(relatives(i, :, :));
         tmpca1 = squeeze(absolutes(parents(i), :, :));
         absolutes(i, :, :) = tmpca1 * tmpca2;
      end
   end
end

function [d_relatives relatives] = d_get_posed_relatives(model, d_pose_params, pose_params)
% default parametrization xzy # Flexion, Abduction, Twist
   T = [];
   d_T = d_zeros(T);
   order = [1 3 2];
   offset = 3;
   n_bones = size(model.bone_names, 1);
   relatives = zeros(n_bones, 4, 4);
   d_relatives = d_zeros(relatives);
   for i_bone=1 : n_bones
      T = eye(4);
      d_T = d_zeros(T);
      tmpda1 = i_bone + offset;
      [tmpada1 T(1 : 3, 1 : 3)] = d_euler_angles_to_rotation_matrix(adimat_opdiff_subsref(d_pose_params, struct('type', '()', 'subs', {{order tmpda1}})), pose_params(order, tmpda1));
      d_T = adimat_opdiff_subsasgn(d_T, struct('type', {'()'}, 'subs', {{1 : 3 1 : 3}}), tmpada1);
      tmpda1 = squeeze(model.base_relatives(i_bone, :, :));
      d_relatives = adimat_opdiff_subsasgn(d_relatives, struct('type', {'()'}, 'subs', {{i_bone ':' ':'}}), adimat_opdiff_mult_left(tmpda1, d_T, T));
      relatives(i_bone, :, :) = tmpda1 * T;
   end
end

function relatives = get_posed_relatives(model, pose_params)
% default parametrization xzy # Flexion, Abduction, Twist
   T = [];
   order = [1 3 2];
   offset = 3;
   n_bones = size(model.bone_names, 1);
   relatives = zeros(n_bones, 4, 4);
   for i_bone=1 : n_bones
      T = eye(4);
      tmpda1 = i_bone + offset;
      T(1 : 3, 1 : 3) = euler_angles_to_rotation_matrix(pose_params(order, tmpda1));
      tmpda1 = squeeze(model.base_relatives(i_bone, :, :));
      relatives(i_bone, :, :) = tmpda1 * T;
   end
end

function [d_R R] = d_euler_angles_to_rotation_matrix(d_xyz, xyz)
   d_tx = adimat_opdiff_subsref(d_xyz, struct('type', '()', 'subs', {{1}}));
   tx = xyz(1);
   d_ty = adimat_opdiff_subsref(d_xyz, struct('type', '()', 'subs', {{2}}));
   ty = xyz(2);
   d_tz = adimat_opdiff_subsref(d_xyz, struct('type', '()', 'subs', {{3}}));
   tz = xyz(3);
   [d_tmpca4 tmpca4] = adimat_diff_cos(d_tx, tx);
   [d_tmpca3 tmpca3] = adimat_diff_sin(d_tx, tx);
   [d_tmpca2 tmpca2] = adimat_diff_sin(d_tx, tx);
   [d_tmpca1 tmpca1] = adimat_diff_cos(d_tx, tx);
   d_Rx = adimat_fdiff_cat(2, adimat_fdiff_cat(3, d_zeros(1), d_zeros(0), d_zeros(0)), adimat_fdiff_cat(3, d_zeros(0), d_tmpca1, -d_tmpca2), adimat_fdiff_cat(3, d_zeros(0), d_tmpca3, d_tmpca4));
   Rx = [1 0 0
         0 tmpca1 -tmpca2
         0 tmpca3 tmpca4];
   [d_tmpca4 tmpca4] = adimat_diff_cos(d_ty, ty);
   [d_tmpca3 tmpca3] = adimat_diff_sin(d_ty, ty);
   [d_tmpca2 tmpca2] = adimat_diff_sin(d_ty, ty);
   [d_tmpca1 tmpca1] = adimat_diff_cos(d_ty, ty);
   d_Ry = adimat_fdiff_cat(2, adimat_fdiff_cat(3, d_tmpca1, d_zeros(0), d_tmpca2), adimat_fdiff_cat(3, d_zeros(0), d_zeros(1), d_zeros(0)), adimat_fdiff_cat(3, -d_tmpca3, d_zeros(0), d_tmpca4));
   Ry = [tmpca1 0 tmpca2
         0 1 0
         -tmpca3 0 tmpca4];
   [d_tmpca4 tmpca4] = adimat_diff_cos(d_tz, tz);
   [d_tmpca3 tmpca3] = adimat_diff_sin(d_tz, tz);
   [d_tmpca2 tmpca2] = adimat_diff_sin(d_tz, tz);
   [d_tmpca1 tmpca1] = adimat_diff_cos(d_tz, tz);
   d_Rz = adimat_fdiff_cat(2, adimat_fdiff_cat(3, d_tmpca1, -d_tmpca2, d_zeros(0)), adimat_fdiff_cat(3, d_tmpca3, d_tmpca4, d_zeros(0)), adimat_fdiff_cat(3, d_zeros(0), d_zeros(0), d_zeros(1)));
   Rz = [tmpca1 -tmpca2 0
         tmpca3 tmpca4 0
         0 0 1];
   d_tmpca1 = adimat_opdiff_mult(d_Rz, Rz, d_Ry, Ry);
   tmpca1 = Rz * Ry;
   d_R = adimat_opdiff_mult(d_tmpca1, tmpca1, d_Rx, Rx);
   R = tmpca1 * Rx;
end

function R = euler_angles_to_rotation_matrix(xyz)
   tx = xyz(1);
   ty = xyz(2);
   tz = xyz(3);
   tmpca4 = cos(tx);
   tmpca3 = sin(tx);
   tmpca2 = sin(tx);
   tmpca1 = cos(tx);
   Rx = [1 0 0
         0 tmpca1 -tmpca2
         0 tmpca3 tmpca4];
   tmpca4 = cos(ty);
   tmpca3 = sin(ty);
   tmpca2 = sin(ty);
   tmpca1 = cos(ty);
   Ry = [tmpca1 0 tmpca2
         0 1 0
         -tmpca3 0 tmpca4];
   tmpca4 = cos(tz);
   tmpca3 = sin(tz);
   tmpca2 = sin(tz);
   tmpca1 = cos(tz);
   Rz = [tmpca1 -tmpca2 0
         tmpca3 tmpca4 0
         0 0 1];
   tmpca1 = Rz * Ry;
   R = tmpca1 * Rx;
end
