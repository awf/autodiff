% Copyright (c) Microsoft Corporation.
% Licensed under the MIT license.

% Generated by ADiMat 0.6.0-4975
% © 2001-2008 Andre Vehreschild <vehreschild@sc.rwth-aachen.de>
% © 2009-2015 Johannes Willkomm <johannes@johannes-willkomm.de>
% TU Darmstadt, 64289 Darmstadt, Germany
% Visit us on the web at http://www.adimat.de/
% Report bugs to adimat-users@lists.sc.informatik.tu-darmstadt.de
%
%                             DISCLAIMER
% 
% ADiMat was prepared as part of an employment at the Institute for Scientific Computing,
% RWTH Aachen University, Germany and at the Institute for Scientific Computing,
% TU Darmstadt, Germany and is provided AS IS. 
% NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL REPUBLIC OF GERMANY
% NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY, NOT THE TU DARMSTADT,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY, EXPRESS OR IMPLIED,
% OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS,
% OR USEFULNESS OF ANY INFORMATION OR PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE
% WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS.
%
% Parameters:
%  - dependents=reproj_err, w_error
%  - independents=cams, X, w
%  - inputEncoding=ISO-8859-1
%
% Functions in this file: d_ba_objective, d_ba_compute_reproj_err,
%  d_rodrigues_rotate_point, rodrigues_rotate_point, d_radial_distort,
%  radial_distort
%

function [d_reproj_err reproj_err d_w_error w_error] = d_ba_objective(d_cams, cams, d_X, X, d_w, w, obs)
%BA_OBJECTIVE Bundle adjustment objective function
%         CAMERAS c x n 
%               matrix containing parameters of n cameras
%               for now, supported format is only
%                 [r1 r2 r3 C1 C2 C3 f u0 v0 k1 k2]'
%               r1,r2,r3 are angle-axis rotation parameters (Rodrigues)
%               [C1 C2 C3]' is the camera center
%               f is the focal length in pixels
%               [u0 v0]' is the principal point
%               k1,k2 are radial distortion parameters
%         X 3 x m 
%               matrix containg m points
%         W 1 x p 
%               vector of weigths for Zach robustifier
%         OBS 2 x p 
%               contains p observations
%               i.e. [camIdx ptIdx x y]
%               where [x y]' is a measurement (a feature)   
%         REPROJ_ERR 2 x p 
%               reprojection errors
% %         F_PRIOR_ERR 1 x n-2 
% %               temporal prior on focals
%         W_ERR 1 x p 
%               1-w^2 
%
%  Xcam = R * (X - C)
%  distorted = radial_distort(projective2euclidean(Xcam),radial_parameters)
%  proj = distorted * f + principal_point
%  err = sqsum(proj - measurement)
   camIdx = [];
   ptIdx = [];
   n = size(cams, 2);
   m = size(X, 2);
   p = size(obs, 2);
   reproj_err = zeros(2, p, 'like', cams);
   d_reproj_err = d_zeros(reproj_err);
   for i=1 : p
      camIdx = obs(1, i);
      ptIdx = obs(2, i);
      [tmpada1 reproj_err(:, i)] = d_ba_compute_reproj_err(adimat_opdiff_subsref(d_cams, struct('type', '()', 'subs', {{':' camIdx}})), cams(:, camIdx), adimat_opdiff_subsref(d_X, struct('type', '()', 'subs', {{':' ptIdx}})), X(:, ptIdx), adimat_opdiff_subsref(d_w, struct('type', '()', 'subs', {{i}})), w(i), obs(3 : 4, i));
      d_reproj_err = adimat_opdiff_subsasgn(d_reproj_err, struct('type', {'()'}, 'subs', {{':' i}}), tmpada1);
   end
   d_tmpca1 = adimat_opdiff_epow_right(d_w, w, 2);
   tmpca1 = w .^ 2;
   d_w_error = adimat_opdiff_sum(-d_tmpca1, d_zeros(1));
   w_error = 1 - tmpca1;
end

function [d_err err] = d_ba_compute_reproj_err(d_cam, cam, d_X, X, d_w, w, feat)
   i_rot = 1 : 3;
   i_C = 4 : 6;
   i_f = 7;
   i_princ_pt = 8 : 9;
   i_rad_params = 10 : 11;
   d_Xo = adimat_opdiff_sum(d_X, -adimat_opdiff_subsref(d_cam, struct('type', '()', 'subs', {{i_C}})));
   Xo = X - cam(i_C);
   [d_Xcam Xcam] = d_rodrigues_rotate_point(adimat_opdiff_subsref(d_cam, struct('type', '()', 'subs', {{i_rot}})), cam(i_rot), d_Xo, Xo);
   d_Xcam_e = adimat_opdiff_div(adimat_opdiff_subsref(d_Xcam, struct('type', '()', 'subs', {{1 : adimat_end(Xcam, 1, 1)-1}})), Xcam(1 : end-1), adimat_opdiff_subsref(d_Xcam, struct('type', '()', 'subs', {{adimat_end(Xcam, 1, 1)}})), Xcam(end));
   Xcam_e = Xcam(1 : end-1) / Xcam(end);
   [d_distorted distorted] = d_radial_distort(adimat_opdiff_subsref(d_cam, struct('type', '()', 'subs', {{i_rad_params}})), cam(i_rad_params), d_Xcam_e, Xcam_e);
   d_tmpca1 = adimat_opdiff_mult(d_distorted, distorted, adimat_opdiff_subsref(d_cam, struct('type', '()', 'subs', {{i_f}})), cam(i_f));
   tmpca1 = distorted * cam(i_f);
   d_proj = adimat_opdiff_sum(d_tmpca1, adimat_opdiff_subsref(d_cam, struct('type', '()', 'subs', {{i_princ_pt}})));
   proj = tmpca1 + cam(i_princ_pt);
   d_tmpca1 = adimat_opdiff_sum(d_proj, d_zeros(-feat));
   tmpca1 = proj - feat;
   d_err = adimat_opdiff_mult(d_w, w, d_tmpca1, tmpca1);
   err = w * tmpca1;
end

function [d_rotatedPt rotatedPt] = d_rodrigues_rotate_point(d_rot, rot, d_pt, pt)
   rotatedPt = [];
   d_rotatedPt = d_zeros(rotatedPt);
   theta = [];
   d_theta = d_zeros(theta);
   costheta = [];
   d_costheta = d_zeros(costheta);
   sintheta = [];
   d_sintheta = d_zeros(sintheta);
   theta_inverse = [];
   d_theta_inverse = d_zeros(theta_inverse);
   w = [];
   d_w = d_zeros(w);
   w_cross_pt = [];
   d_w_cross_pt = d_zeros(w_cross_pt);
   tmp = [];
   d_tmp = d_zeros(tmp);
   rot_cross_pt = [];
   d_rot_cross_pt = d_zeros(rot_cross_pt);
   d_tmpca1 = adimat_opdiff_epow_right(d_rot, rot, 2);
   tmpca1 = rot .^ 2;
   d_sqtheta = adimat_diff_sum1(d_tmpca1, tmpca1);
   sqtheta = sum(tmpca1);
   if sqtheta ~= 0
      [d_theta theta] = adimat_diff_sqrt(d_sqtheta, sqtheta);
      [d_costheta costheta] = adimat_diff_cos(d_theta, theta);
      [d_sintheta sintheta] = adimat_diff_sin(d_theta, theta);
      d_theta_inverse = adimat_opdiff_div_left(1., d_theta, theta);
      theta_inverse = 1. / theta;
      d_w = adimat_opdiff_mult(d_rot, rot, d_theta_inverse, theta_inverse);
      w = rot * theta_inverse;
      [d_w_cross_pt w_cross_pt] = adimat_diff_cross1(d_w, w, d_pt, pt);
      d_tmpca2 = adimat_opdiff_mult(adimat_opdiff_trans(d_w, w), w', d_pt, pt);
      tmpca2 = w' * pt;
      d_tmpca1 = adimat_opdiff_sum(-d_costheta, d_zeros(1.));
      tmpca1 = 1. - costheta;
      d_tmp = adimat_opdiff_mult(d_tmpca1, tmpca1, d_tmpca2, tmpca2);
      tmp = tmpca1 * tmpca2;
      d_tmpca3 = adimat_opdiff_mult(d_tmp, tmp, d_w, w);
      tmpca3 = tmp * w;
      d_tmpca2 = adimat_opdiff_mult(d_sintheta, sintheta, d_w_cross_pt, w_cross_pt);
      tmpca2 = sintheta * w_cross_pt;
      d_tmpca1 = adimat_opdiff_mult(d_costheta, costheta, d_pt, pt);
      tmpca1 = costheta * pt;
      d_rotatedPt = adimat_opdiff_sum(d_tmpca1, d_tmpca2, d_tmpca3);
      rotatedPt = tmpca1 + tmpca2 + tmpca3;
   else
      [d_rot_cross_pt rot_cross_pt] = adimat_diff_cross1(d_rot, rot, d_pt, pt);
      d_rotatedPt = adimat_opdiff_sum(d_pt, d_rot_cross_pt);
      rotatedPt = pt + rot_cross_pt;
   end
end

function rotatedPt = rodrigues_rotate_point(rot, pt)
   rotatedPt = [];
   theta = [];
   costheta = [];
   sintheta = [];
   theta_inverse = [];
   w = [];
   w_cross_pt = [];
   tmp = [];
   rot_cross_pt = [];
   tmpca1 = rot .^ 2;
   sqtheta = sum(tmpca1);
   if sqtheta ~= 0
      theta = sqrt(sqtheta);
      costheta = cos(theta);
      sintheta = sin(theta);
      theta_inverse = 1. / theta;
      w = rot * theta_inverse;
      w_cross_pt = cross(w, pt);
      tmpca2 = w' * pt;
      tmpca1 = 1. - costheta;
      tmp = tmpca1 * tmpca2;
      tmpca3 = tmp * w;
      tmpca2 = sintheta * w_cross_pt;
      tmpca1 = costheta * pt;
      rotatedPt = tmpca1 + tmpca2 + tmpca3;
   else
      rot_cross_pt = cross(rot, pt);
      rotatedPt = pt + rot_cross_pt;
   end
end

function [d_x x] = d_radial_distort(d_kappa, kappa, d_x, x)
   d_tmpca1 = adimat_opdiff_epow_right(d_x, x, 2);
   tmpca1 = x .^ 2;
   d_sqr = adimat_diff_sum1(d_tmpca1, tmpca1);
   sqr = sum(tmpca1);
   d_tmpca3 = adimat_opdiff_mult(adimat_opdiff_subsref(d_kappa, struct('type', '()', 'subs', {{2}})), kappa(2), d_sqr, sqr);
   tmpca3 = kappa(2) * sqr;
   d_tmpca2 = adimat_opdiff_mult(d_tmpca3, tmpca3, d_sqr, sqr);
   tmpca2 = tmpca3 * sqr;
   d_tmpca1 = adimat_opdiff_mult(adimat_opdiff_subsref(d_kappa, struct('type', '()', 'subs', {{1}})), kappa(1), d_sqr, sqr);
   tmpca1 = kappa(1) * sqr;
   d_L = adimat_opdiff_sum(d_tmpca1, d_tmpca2, d_zeros(1));
   L = 1 + tmpca1 + tmpca2;
   d_x = adimat_opdiff_mult(d_x, x, d_L, L);
   x = x * L;
end

function x = radial_distort(kappa, x)
   tmpca1 = x .^ 2;
   sqr = sum(tmpca1);
   tmpca3 = kappa(2) * sqr;
   tmpca2 = tmpca3 * sqr;
   tmpca1 = kappa(1) * sqr;
   L = 1 + tmpca1 + tmpca2;
   x = x * L;
end
